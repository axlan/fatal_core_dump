; ASCII-only x64 assembly that triggers segmentation fault
; Every byte is printable ASCII (0x20-0x7E)

BITS 64

; Simplest approach that works:
; We need to create a NULL pointer and dereference it

; Method: Push/pop to zero registers, then access memory

; 0x50-0x57 = push r8-r15 (all ASCII: P,Q,R,S,T,U,V,W)
; 0x58-0x5F = pop r8-r15 (all ASCII: X,Y,Z,[,\,],^,_)
; 0x48 = REX.W prefix (ASCII: H)
; 0x21 = and instruction (ASCII: !)

section .text
global _start

_start:
    ; db 0x50        ; push rax (P)
    ; db 0x58        ; pop rax  (X) - rax likely contains small/zero value
    ; db 0x48, 0x21, 0x20   ; and [rax+0x20], ah - will segfault
    ;                     ; H (0x48), ! (0x21), space (0x20)
    ; ; Explanation:
    ; ; - Initial push/pop manipulates registers
    ; ; - The "and [rax+offset], reg" instruction attempts memory access
    ; ; - If rax is zero or invalid, this causes segmentation fault
    ; ; - All bytes (0x50, 0x58, 0x48, 0x21, 0x20) are printable ASCII


    ; a=b'{"auto_adjust":true,"emergency_cooling_threshold":35.0,"heating_mode":"adaptive"}'
    ; ','.join(hex(int(b)) for b in a)
    ;
    mov al, 0x00 ; al = 0000 0011 (two 1-bits -> even parity, PF=1)
    db 0x7b,0x22,0x61,0x75,0x74,0x6f,0x5f,0x61,0x64,0x6a,0x75,0x73,0x74,0x22,0x3a,0x74,0x72,0x75,0x65,0x2c,0x22,0x65,0x6d,0x65,0x72,0x67,0x65,0x6e,0x63,0x79,0x5f,0x63,0x6f,0x6f,0x6c,0x69,0x6e,0x67,0x5f,0x74,0x68,0x72,0x65,0x73,0x68,0x6f,0x6c,0x64,0x22,0x3a,0x33,0x35,0x2e,0x30,0x2c,0x22,0x68,0x65,0x61,0x74,0x69,0x6e,0x67,0x5f,0x6d,0x6f,0x64,0x65,0x22,0x3a,0x22,0x61,0x64,0x61,0x70,0x74,0x69,0x76,0x65,0x22,0x7d
; 00000000  7B22              jpo 0x24 ; Won't jump, PF=1
; 00000002  61                db 0x61

